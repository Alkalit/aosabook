# Audacity

James Crook

Audacity是一个流行的录音机和音频编辑器程序。它功能强大，而且易于使用。Audacity的主要用户来自Windows平台，不过可以通过编译源码在Linux和Mac平台上运行。

Dominic Mazzoni在1999年写了Audacity的第一版，那时他还只是卡内基梅隆大学的一名研究生（research student）。Dominic目的是创建一个平台，可以在上面开发和调试音频处理算法。不过，这个软件本身逐渐发展，在很多其他方面也变得有用起来。Audacity刚刚宣布作为开源软件发布，它就吸引了别的开发者。多年以来，一个小的、不断变化的、由爱好者组成的团队负责修改、维护、测试、更新、写文档、帮助用户、把Audacity的界面翻译成其他语言。

Audacity的目标之一是它的用户界面应该是可发现的（discoverable）：用户应该不用翻手册，坐下之后就开始使用它，逐渐地发现它的特性。这个原则很关键，为 Audacity赋予更高的用户界面一致性胜过其他。对于有很多人一起合作的项目来说，这种统一的原则比刚开始想象的要更重要。

如果Audacity的架构也有相似的指导原则或者说相似的可发现性就好了。在这方面，我们最接近的原则是“尽量保持一致性”。在增加新代码时，开发者试着遵守附近原有代码的风格和惯例。但是在实践中，Audacity代码库是由组织良好的代码和组织较差的代码混合组成的。相比整体架构，小城市的比喻可能更恰当：小城市里有一些漂亮的建筑，也有一些破旧的地区更像是贫民窟。

## 2.1. Audacity中的结构

Audacity在几个库之上是分层架构的。虽然在Audicity中写新的程序并不需要了解到底这些库具体是怎么回事，但是熟悉它们的API、了解它们的机制也是很重要的。其中最重要的两个库分别是PortAudio，使用提供了跨平台的低级别音频接口和wxWidgets，提供了跨平台的图形用户界面（GUI）组件。

在阅读Audacity源码时，看起来只有代码的一部分是核心。库贡献了很多可选的特性——虽然使用这些特性的人科恩可能没有想到这一点。例如，Audacity有内建的音效功能，同时它也支持LADSPA（Linux音频开发者简单插件API）开发动态载入音效插件。Audicity中的VAMP API对于开发分析音频的插件也起到了相同的作用。没有这些API，Audicity就不会有那么多特性了，但是它本身并不依赖这些特性。

Audicity其他可选的库有libFLAC、ligogg和libvorbis。这些库提供了多种音频压缩格式。通过动态加载LAME或FFmpeg库可以使用MP3格式。授权限制阻止了这些非常流行的压缩库进入Audicity的内建特性。

关于Audicity库和结构的一些决定是由于授权的原因。例如，支持VST插件没有放在里面是因为授权限制。我们也想使用非常高效的FFTW快速傅里叶变换，而不是后退到我们正常构建中使用的有点慢的版本。只要Audacity支持插件，Aducity不用FFTW就有争议。FFTW的作者不想让他们的代码成为其他别的代码的一般性服务。所以，支持插件的架构决定导致我们能提供什么的权衡（重译）。这个决定使得LADSPA插件成为可能，但是阻止我们使用FFTW在我们预构建的二进制里。

架构也会被如何最好地利用我们稀缺的开发者时间这种考虑所影响（重译）。在一个小的开发者团队，我们没有资源去做，例如像Firefox或Thunderbird团队那样，深入分析安全漏洞。然而，我们不想让Audacity提供一个路由穿过防火墙，所以我们有一条规则，那就是彻底切断Audcity的TCP/IP连接。不用TCP/IP就避免了很多安全隐患。了解我们有限的资源，我们就会产生更好的设计。基于这一点，我们去掉一些花费太多开发者时间的特性，而只关心最重要的东西。

对于脚本语言来说，我们也开发者的时间（重译）。我们需要脚本，但是实现脚本语言的代码没有必要包含在Audacity里。把很多份脚本语言编译到Audacity里，让用作出选择并不合适。相反，我们使用一个单独的插件模块和管道实现了脚本，具体内容我们在下面就讲到。

<div align="center"><img src="img/audacity/Layers.png"></div>
<div align="center">图1.1 Audacity中的层次</div>


图2.1展示了Audacity中的一些层和模块。图中强调了wxWidgets中三个重要的类，每个类在Audacity中都有相应实现。我们在从相对较低层次构建更高层次的抽象。例如，BlockFile系统是wxWidgets的wxFiles的映射，并且构建在其上（重译）。在某一阶段，可能把BlockFiles、ShuttleGUI分开比较好，并且把处理逻辑放到中间库中。这会鼓励我们使得它们更加通用。

在图的下侧，有一个窄长条，标题是“平台相关的实现层”（"Platform Specific Implementation Layers"）。wxWidgets和PortAudio都是操作系统（OS）的抽象层。两者都包含条件判断代码，根据目标平台选择不同的实现。

“其他支撑库”（"Other Supporting Libraries"）部分则包含了为数众多的库。有趣的是，其中的很多都依赖于动态加载的模块，而那些动态模块对于wxWidgets一无所知。

在Windows平台上，我们习惯把Audacity编译成一个单独的可执行文件，其中包括了wxWidgets和Audacity的应用程序代码。2008年，我们改成使用一个模块化的结构，把wxWidgets编译成单独的DLL<sup>1</sup>。这样其他可选的DLL就可以在运行时被加载，并且可以使用wxWidgets的特性。图中虚线上方插入的插件可以使用wxWidgets。

把wxWidgets编译成DLL的机制也有弊端。现在的分发包更大了，部分原因是DLL中提供的很多不用的功能之前都会被优化掉。Audacity也需要花更长的时间启动，因为每个DLL都需要分别加载。好处也是显而易见的。我们希望模块化能给我们带来好处，就像Apache一样。就我们的理解，模块化允许Apache的内核非常稳定，同时又能促进模块中的实验、特别的特性和新的想法加入。模块化对于抵挡住拉出一个分支从而把Audacity带到另一个方向的诱惑大有帮助（重译）。我们想这对我们来说是非常重要的变化预案。我们期望得到这些好处，但是还没有看到。把wxWidgets功能暴露出来只是第一步，实际上我们为了得到一个灵活的模块化系统还有更多工作要做。

像Audacity这样的程序结构显然不是事先设计的。它差不多是随着时间逐渐发展起来的。总体来说，我们现在的架构运转的还不错。当我们尝试加入的新特性影响很多源文件时，我们就得和架构作斗争。例如，Audacity现在使用特殊的方式处理立体声和单声道。如果你想要修改Audacity，使它能够处理环绕立体声的话，你就需要在Audacity里改动很多类文件。

### 译者注
  1. DLL: DLL Dynamic Link Library 动态链接库
  2. 



