#Asterisk

Russell Bryant

Asterisk<sup>1</sup>是一个开源的电话通讯应用软件平台，授权协议是GPLv2。简而言之，Asterisk就是一个打电话、接电话和对电话进行定制化处理的服务器端应用程序。

这个项目是由Mark Spencer在1999年启动的。Mark有一个公司叫Linux支持服务公司，他需要一个电话系统帮助他运营业务。他没钱去买一个系统，所以就自己做了一个。当Asterisk逐渐流行起来，Linux支持服务公司就把业务转向了Asterisk，并且把公司的名字改成Digium公司。

Asterisk这个名字来自Unix通配符，*。Asterisk项目的目标是能完成所有的电话通信事务。通过追求这个目标，Asterisk现在可以支持一长串接打电话的技术。这里面包括很多VoIP（Voice Over IP：网络电话技术）协议，也包括到传统电话网络的模拟和数字连接，或者到PSTN（Public Switched Telephone Network： 公用电话交换网）的连接。Asterisk的主要强项就是系统能够接打和拨出多种类型的电话。

一旦从Asterisk系统接到或拨出了电话，那么就用很多方式来处理这些电话。有些功能更加通用一些，例如语音信箱，这些功能就预制在系统里。也有其他的一些小功能可以组合在一起创建一个定制化的语音应用，例如回放声音文件、读出数字或语音识别等。

##1.1. 关键的架构概念

本节讨论一些架构上的概念，这些概念对于Asterisk的所有部分都很关键。这些概念是Asterisk架构的基础。

###1.1.1. 通道（Channels）

Asterisk中的通道表示Asterisk系统和一些电话通讯节点的连接（如图1.1所示）。最常见的例子是当一部电话接入Asterisk系统的时候。这个连接就是由一个单独的通道表示。在Asterisk代码里，一个通道就是ast_channel数据结构的一个实例。举个例子来说，这个通话场景可能是一个人正和语音信箱交互。

<div align="center"><img src="img/singleChannel.png"></div>
<div align="center">图1.1 由一个单通道表示的单个电话支路</div>

###1.1.2. 通道桥接

可能更熟悉的一种通话场景是两个电话之间的连接，就是一个人用电话A呼叫另一个人的电话B。在这种情况下，有两个电话通讯节点连接到Asterisk系统，所以这个通话存在两个通道（如图1.2所示）。

<div align="center"><img src="img/twoChannels.png"></div>
<div align="center">图1.2 由两个通道表示的两个电话支路</div>

像这样连接的Asterisk通道，我们称之为一个通道桥。通道桥接是为了传递媒体的目的把通道连接在一起的行为。媒体流通常情况下是音频流。然而，通话过程中也可能有视频或文字流。即使有多个媒体流（例如既有音频又有视频）存在，在Asterisk系统里都是由通话节点的一个单通道处理的。在图1.2中，电话A和电话B有两个通道，中间的桥负责把媒体从电话A传到电话B，同样，也把媒体从电话B传到电话A。所有的媒体流都要通过Asterisk进行协商。任何Asterisk所不能理解或不能完全控制的东西都是不允许的。这意味着Asterisk可以在不同的技术之间进行录音、音频处理和翻译。

如果需要把两个通道桥接在一起，有两种方法可以完成：通用桥接和本地桥接。通用桥接就是不管使用的是什么通道技术。它通过Asterisk抽象通道接口传递所有的音频和信令。虽然这是最灵活的桥接方法，但是这也是效率最低的，因为为了完成这个任务用了过多抽象层。图1.2给出了一个通用桥的例子。

本地桥是使用一种特定的技术把通道连接在一起的方法。如果连接到Asterisk上的两个通道使用的是同样的媒体传输技术，那么可能存在一种方法，可以比通过Asterisk中连接不同技术的多个抽象层的方法更有效率。例如，如果连接到电话网络的是特殊的硬件，那就可以把通道架设在硬件之上，这样的话媒体就完全不用经过应用程序了。对于VoIP协议来说，节点两端就可以直接互相发送媒体流，最后就只有通话信令继续在服务器上传送了。

选择通用桥接还是本地桥接，是在对两个通道进行桥接的时候决定的。如果两个通道表明支持同一种本地桥接方法，那么就会用本地桥接。否则，就使用通用桥接方法。为了确定两个通道是否支持同样的本地桥接方法，程序中使用了简单的C函数指针比较。这肯定不是最优雅的方式，但是我们还没有遇到效率上满足不了我们需要的场景。1.2节中讨论了提供本地桥接函数的更多细节。图1.3给出了一个本地桥接的例子。

<div align="center"><img src="img/nativeBridge.png"></div>
<div align="center">图1.3 本地桥接的例子</div>

### 1.1.3. 帧

在通话的过程中和Asterisk代码沟通是通过帧来完成的，这里的帧就是ast_frame数据结构的实例。帧分为媒体帧和信令帧两种。在一个普通的电话呼叫中，包含音频的媒体帧的流会在系统中传递。信令帧则是用来发送通话信令事件的消息，例如按下一个数字键、通话正处于保持状态或者通话挂断。

可用的帧类型列表是预先定义好的。每个帧都通过一个数字编码类型和子类型来标识。完整的类型列表可以在源代码文件include/asterisk/frame.h中找到；下面给出一些例子：

 - `VOICE`：这种帧承载了视频系统的一部分。
 - `VIDEO`：这种帧承载了音频系统的一部分。
 - `MODEM`：帧里面数据的编码方式，例如T.38指示发送网络传真。这种帧类型的主要用途是为了处理传真。帧内的数据可以完全不需要处理，这样信号可以在另一端正确解码，这是非常重要的。它和`AUDIO`不太一样，后者为了节省带宽可以接受降低音频质量。
 - `CONTROL`：这种类型的帧说明它是通话信令消息。这种帧使用来表明通话信令事件的。事件包括电话正在被接听，挂断或保持等等。
 - `DTMF_BEGIN`：有数字键被按下。当呼叫者在电话上按下一个DTMK键就会发送这种帧。
 - `DTMF_END`：有数字键按键完成。当呼叫者停止按DTMK键时就会发送这种帧。

##1.2. Asterisk组件的抽象

Asterisk是一个高度模块化的应用程序。有一个从源代码目录`main/`中编译的核心应用。不过，这个核心应用自己做不了什么。它的主要目的是作为模块注册表。其中也有代码知道怎样把所有的抽象接口连接在一起，从而让电话能打通。这些接口的具体实现是在运行时通过可加载的模块注册进来的。

默认情况下，在主应用程序启动时，所有在Asterisk模块目录中预定义的所有模块都会被加载进来。这么做就是为了简单。另外，也可以更新一个配置文件来指明具体加载哪些模块，以什么顺序加载。这样导致配置有点复杂，但是提供了不用的模块就不用加载的能力。最大的好处是降低应用程序的内存占用。当然，也有一些安全性上的好处。如果不需要网络通话的话，那就不需要加载接受网络连接的模块了。

当一个模块被加载时，它会在Asterisk核心应用中注册所有组件抽象的实现。模块可以实现很多种类型的接口并注册到Asterisk核心应用。一个模块像注册多少不同的接口都是允许的。通常来说，功能相关的接口可以放在一个模块里。

1.2.1. 通道驱动

Asterisk通道驱动接口是最复杂也是最重要的可用接口。Asterisk通道API提供电话通讯协议抽象层，允许所有其他的Asterisk特性可以独立工作，不依赖于所使用的电话通讯协议。这个组件负责在Asterisk通道抽象层和实现抽象层的电话通讯技术细节之间进行翻译。

Asterisk通道驱动接口叫做`ast_channel_tech`接口。这个接口定义了一组必须被每个通道驱动实现的方法。第一个通道驱动必须要实现的方法是一个工厂方法`ast_channel`，也就是`ast_channel_tech`中的请求者方法。当一个Asterisk通道建立之后，无论对于拨进来的电话还是拨出去的电话，和所需通道类型相关联的`ast_channel_tech`的实现负责该通话中`ast_channel`的实例化和初始化。

一旦一个`ast_channel`建立了，它就有一个创建它的`ast_channel_tech`的引用。有很多其他的操作必须用具体的技术来处理。如果有些操作必须在`ast_channel`上实现，那么这些操作的处理就会延迟到`ast_channel_tech`中合适的方法。图1.2展示了Asterisk中的两个通道。图1.4扩展了图1.2，展示了两个桥接通道，以及通道技术的实现在整个架构中的作用。

<div align="center"><img src="img/channelLayers.png"></div>
<div align="center">图1.4 通道技术和抽象的通道层</div>

ast_channel_channel中最重要的方法是：
 - requester: 这个回调函数是用来请求一个通道驱动，进而可以实例化为一个ast_channel对象，并且根据通道类型进行初始化。
 - call: 这个回调函数是用来向由ast_channel表示的一个终端发起呼出电话。
 - answer: 当Asterisk决定应答和当前ast_channel关联的呼入电话时调用。
 - hangup: 当系统确定当前通话应该挂断时调用。然后，通道驱动就会通过一种专用协议告诉终端当前通话已经结束。
 - indicate: 一旦通话建立成功，有很多其他可能会发生的事件需要通知到终端。例如，如果设备被置为保持状态，这个回调函数就会被调用以说明这个情况。可能有一种专用协议的方法表明当前通话被保持，或者通道驱动可能简单地为设备播放保持通话的音乐。
 - send_digit_begin: 调用这个函数是为了表明正在发送到本设备的一个数字（DTMF）的开始。
 - send_digit_end: 调用这个函数是为了表明正在发送到本设备的一个数字（DTMF）的结尾。
 - read: Asterisk核心模块调用这个函数的目的是从当前终端读取一个ast_frame的帧。一个ast_frame帧在Asterisk中是一种抽象，用来包装媒体（例如音频或视频），也用来发送事件。
 - write: 这个函数的目的是发送一个ast_frame帧到当前设备。通道驱动会拿到数据然后根据它实现的通讯协议用合适的方式打包并传递到终端。
 - bridge: 本通道类型的本地桥接回调函数。如上所述，本地桥接是当一个通道驱动能够为两个相同类型的通道实现一个更加有效的桥接方法，而不用让所有的信令和媒体流过多余的不必要的抽象层。它对于性能至关重要。

一旦通话结束，位于Asterisk核心模块中处理代码的抽象通道会调用`ast_channel_tech`的hangup回调函数，然后销毁ast_channel对象。

###1.2.2. Dialplan应用程序

Asterisk管理员使用dialplan设置呼叫路由，具体位置在/etc/asterisk/extensions.conf文件中。dialplan是由一系列称作扩展的呼叫规则组成的。当一个电话接入系统，所拨号码会被用来寻找dialplan中的扩展，用来处理当前呼叫。这个扩展中包含了一列dialplan应用程序，这些应用程序会在当前通道执行。dialplan中可以执行的应用程序在应用程序列表中维护。当模块载入完成时，这个注册表会在运行时填入。 

Asterisk有将近两百个包含的应用程序。应用程序的定义非常松散。应用程序可以使用任意的Asterisk内部API和当前通道交互。有些应用程序只完成一个任务，例如回放，也就是给呼叫者播放一段声音文件。其他的一些应用程序则更投入，可以执行大量的操作，例如语音信箱程序。

使用Asterisk的dialplan，多个应用程序可以组合在一起来定制呼叫处理。如果需要更大范围的定制化，超过了dialplan所能提供的范围，那么还有一种脚本接口可以允许使用任何编程语言来定制呼叫处理。即使使用其他编程语言写的这些脚本接口，dialplan应用程序还是会被调用用来和通道交互。

在我们进入一个例子之前，让我们来看一看Asterisk的dialplan处理呼叫数字1234的语法。注意选择1234是随机的。它会调用三个dialplan应用程序。首先，它应答这个呼叫。接着它播放一段声音文件。最后，它挂断通话。

```
; Define the rules for what happens when someone dials 1234.
;
exten => 1234,1,Answer()
    same => n,Playback(demo-congrats)
    same => n,Hangup()
```

关键字exten用来定义扩展。在exten那一行的右侧，1234意思是我们正在定义某人呼叫1234时的规则。下面的1意思是，这是这个号码拨了之后的第一步。最后的Answer告诉系统应答这个呼叫。接下来的两行都以same关键字开头，定义了上一个扩展的规则，这个例子里是1234的规则。n的意思是这是下一步要做的事。这两行里最后一项说明要采取什么行动。

下面是使用dialplan的另一个例子。在这个例子里，一个呼入电话被应答。呼叫者听到了一声“嘀“，然后4个数字从呼叫者读入并存储到DIGITS变量。然后，这些数字被读回给呼叫者。最后，呼叫结束。

```
exten => 5678,1,Answer()
    same => n,Read(DIGITS,beep,4)
    same => n,SayDigits(${DIGITS})
    same => n,Hangup()
```

前面也提到过，应用程序的定义非常松散——注册的函数原型非常简单：

```
int (*execute)(struct ast_channel *chan, const  char *args);
```

其实，应用程序的实现几乎使用了include/asterisk/下面的所有的API。


###脚注
1. [http://www.asterisk.org/](http://www.asterisk.org/)
2. DTMF代表双音多频。当有人在电话上按键的时候，在电话通话音频中发出的音调就是双音多频的实例。




















